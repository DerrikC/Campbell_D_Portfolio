'use strict';

var express = require('express');
var methods = require('methods').concat('all');

var isNil = function isNil(val) {
	return val === null || val === undefined;
};

var createHandleWrapper = function createHandleWrapper(handler) {
	// TODO: maybe handle express `use` method as well?
	return function (req, res, next) {
		// express already handles error throwing, so no need to wrap this in
		// another try/catch.
		var ret = handler(req, res, next);

		// In some cases, it makes sense to just call the send method manually,
		// for example to stream data.
		if (isNil(ret)) {
			return;
		}

		// We have a thenable.
		if (typeof ret.then === 'function') {
			ret.then(function (r) {
				if (!isNil(r)) {
					res.status(200).send(r);
				}
			}, next);
			return;
		}

		res.status(200).send(ret);
	};
};
// jscs:disable
var RouterWrapper = function RouterWrapper(internal) {
	this.internal = internal;
};
// jscs:enable

methods.forEach(function (method) {
	// No choice for this one...
	// jscs:disable
	RouterWrapper.prototype[method] = function () {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		// jscs:enable

		// Theres a couple of cases that this needs to handle. The first is the
		// basic syntax with the string at the begning. For some of the
		//var args = Array.prototype.slice.call(arguments);
		var isRg = typeof args[0] === 'string';
		var handlerList = isRg ? args.slice(1) : args;
		var head = isRg ? args[0] : null;
		//		if(typeof args[0] === 'string') {
		//			handlerList = args.slice(1);
		//			head = args[0];
		//		} else {
		//			handlerList = args;
		//		}

		// And then I need to process potential arrays...
		var handlers = handlerList.map(function (handler) {
			if (Array.isArray(handler)) {
				return handler.map(createHandleWrapper);
			}
			return createHandleWrapper(handler);
		});
		var passArgs = head ? [head].concat(handlers) : handlers;
		this.internal[method].apply(this.internal, passArgs);
	};
});

// jscs:disable
RouterWrapper.prototype.route = function () {
	// jscs:enable
	var router = this.internal.route.apply(this.internal, arguments);
	return new RouterWrapper(router);
};

// Remove wrapper instances before passing the arguments to the express
// instance.
// Hmm should this be recursive?
var unwrap = function unwrap(w) {
	var args = [];
	Array.prototype.forEach.call(w, function (arg) {
		if (arg instanceof RouterWrapper) {
			args.push(arg.internal);
		} else {
			args.push(arg);
		}
	});

	return args;
};

var routerWrapperKeys = Object.keys(RouterWrapper.prototype).concat('internal');

/**
 * Everything else just needs to be passed over to the express instance.
 */
var proxyExpress = function proxyExpress(wrapper) {
	Object.keys(wrapper.internal).filter(function (k) {
		return routerWrapperKeys.indexOf(k) === -1;
	}).forEach(function (k) {
		var orig = wrapper.internal[k];

		if (typeof orig === 'function') {
			// jscs:disable
			wrapper[k] = function () {
				// jscs:enable
				return this.internal[k].apply(this.internal, unwrap(arguments));
			};
		} else {
			Object.defineProperty(wrapper, k, {
				get: function get() {
					return wrapper.internal[k];
				}
			});
		}
	});
	return wrapper;
};

exports = module.exports = function () {
	var app = express();
	return proxyExpress(new RouterWrapper(app));
};

exports.Router = function (options) {
	var router = express.Router(options);
	return proxyExpress(new RouterWrapper(router));
};

Object.keys(express).filter(function (k) {
	return k !== 'Router';
}).forEach(function (k) {
	exports[k] = express[k];
});
//# sourceMappingURL=data:application/json;base64,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QUFiLENBQVAsQ0FGZ0M7Q0FBTjs7QUFLM0IsUUFBUSxNQUFSLEdBQWlCLFVBQUMsT0FBRCxFQUFhO0FBQzdCLEtBQU0sU0FBUyxRQUFRLE1BQVIsQ0FBZSxPQUFmLENBQVQsQ0FEdUI7QUFFN0IsUUFBTyxhQUFhLElBQUksYUFBSixDQUFrQixNQUFsQixDQUFiLENBQVAsQ0FGNkI7Q0FBYjs7QUFLakIsT0FDRSxJQURGLENBQ08sT0FEUCxFQUVFLE1BRkYsQ0FFUyxVQUFDLENBQUQ7UUFBTyxNQUFNLFFBQU47Q0FBUCxDQUZULENBR0UsT0FIRixDQUdVLFVBQUMsQ0FBRCxFQUFPO0FBQ2YsU0FBUSxDQUFSLElBQWEsUUFBUSxDQUFSLENBQWIsQ0FEZTtDQUFQLENBSFYiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XG5jb25zdCBtZXRob2RzID0gcmVxdWlyZSgnbWV0aG9kcycpLmNvbmNhdCgnYWxsJyk7XG5cbmNvbnN0IGlzTmlsID0gKHZhbCkgPT4ge1xuXHRyZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgY3JlYXRlSGFuZGxlV3JhcHBlciA9IChoYW5kbGVyKSA9PiB7XG5cdC8vIFRPRE86IG1heWJlIGhhbmRsZSBleHByZXNzIGB1c2VgIG1ldGhvZCBhcyB3ZWxsP1xuXHRyZXR1cm4gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG5cdFx0Ly8gZXhwcmVzcyBhbHJlYWR5IGhhbmRsZXMgZXJyb3IgdGhyb3dpbmcsIHNvIG5vIG5lZWQgdG8gd3JhcCB0aGlzIGluXG5cdFx0Ly8gYW5vdGhlciB0cnkvY2F0Y2guXG5cdFx0Y29uc3QgcmV0ID0gaGFuZGxlcihyZXEsIHJlcywgbmV4dCk7XG5cblx0XHQvLyBJbiBzb21lIGNhc2VzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0IGNhbGwgdGhlIHNlbmQgbWV0aG9kIG1hbnVhbGx5LFxuXHRcdC8vIGZvciBleGFtcGxlIHRvIHN0cmVhbSBkYXRhLlxuXHRcdGlmKGlzTmlsKHJldCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSBoYXZlIGEgdGhlbmFibGUuXG5cdFx0aWYodHlwZW9mIHJldC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXRcblx0XHRcdFx0LnRoZW4oKHIpID0+IHtcblx0XHRcdFx0XHRpZighaXNOaWwocikpIHtcblx0XHRcdFx0XHRcdHJlcy5zdGF0dXMoMjAwKS5zZW5kKHIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgbmV4dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVzLnN0YXR1cygyMDApLnNlbmQocmV0KTtcblx0fTtcblxufTtcbi8vIGpzY3M6ZGlzYWJsZVxuY29uc3QgUm91dGVyV3JhcHBlciA9IGZ1bmN0aW9uKGludGVybmFsKSB7XG5cdHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbn07XG4vLyBqc2NzOmVuYWJsZVxuXG5tZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuXHQvLyBObyBjaG9pY2UgZm9yIHRoaXMgb25lLi4uXG5cdC8vIGpzY3M6ZGlzYWJsZVxuXHRSb3V0ZXJXcmFwcGVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oLi4uYXJncykge1xuXHRcdC8vIGpzY3M6ZW5hYmxlXG5cdFx0XG5cdFx0Ly8gVGhlcmVzIGEgY291cGxlIG9mIGNhc2VzIHRoYXQgdGhpcyBuZWVkcyB0byBoYW5kbGUuIFRoZSBmaXJzdCBpcyB0aGVcblx0XHQvLyBiYXNpYyBzeW50YXggd2l0aCB0aGUgc3RyaW5nIGF0IHRoZSBiZWduaW5nLiBGb3Igc29tZSBvZiB0aGVcblx0XHQvL3ZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRjb25zdCBpc1JnID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnO1xuXHRcdGNvbnN0IGhhbmRsZXJMaXN0ID0gaXNSZyA/IGFyZ3Muc2xpY2UoMSkgOiBhcmdzO1xuXHRcdGNvbnN0IGhlYWQgPSBpc1JnID8gYXJnc1swXSA6IG51bGw7XG4vL1x0XHRpZih0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbi8vXHRcdFx0aGFuZGxlckxpc3QgPSBhcmdzLnNsaWNlKDEpO1xuLy9cdFx0XHRoZWFkID0gYXJnc1swXTtcbi8vXHRcdH0gZWxzZSB7XG4vL1x0XHRcdGhhbmRsZXJMaXN0ID0gYXJncztcbi8vXHRcdH1cblxuXHRcdC8vIEFuZCB0aGVuIEkgbmVlZCB0byBwcm9jZXNzIHBvdGVudGlhbCBhcnJheXMuLi5cblx0XHRjb25zdCBoYW5kbGVycyA9IGhhbmRsZXJMaXN0Lm1hcCgoaGFuZGxlcikgPT4ge1xuXHRcdFx0aWYoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlci5tYXAoY3JlYXRlSGFuZGxlV3JhcHBlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlSGFuZGxlV3JhcHBlcihoYW5kbGVyKTtcblx0XHR9KTtcblx0XHRjb25zdCBwYXNzQXJncyA9IGhlYWQgPyBbaGVhZF0uY29uY2F0KGhhbmRsZXJzKSA6IGhhbmRsZXJzO1xuXHRcdHRoaXMuaW50ZXJuYWxbbWV0aG9kXS5hcHBseSh0aGlzLmludGVybmFsLCBwYXNzQXJncyk7XG5cdH07XG59KTtcblxuLy8ganNjczpkaXNhYmxlXG5Sb3V0ZXJXcmFwcGVyLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBqc2NzOmVuYWJsZVxuXHRjb25zdCByb3V0ZXIgPSB0aGlzLmludGVybmFsLnJvdXRlLmFwcGx5KHRoaXMuaW50ZXJuYWwsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBuZXcgUm91dGVyV3JhcHBlcihyb3V0ZXIpO1xufTtcblxuLy8gUmVtb3ZlIHdyYXBwZXIgaW5zdGFuY2VzIGJlZm9yZSBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIGV4cHJlc3Ncbi8vIGluc3RhbmNlLlxuLy8gSG1tIHNob3VsZCB0aGlzIGJlIHJlY3Vyc2l2ZT9cbmNvbnN0IHVud3JhcCA9ICh3KSA9PiB7XG5cdGNvbnN0IGFyZ3MgPSBbXTtcblx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh3LCAoYXJnKSA9PiB7XG5cdFx0aWYoYXJnIGluc3RhbmNlb2YgUm91dGVyV3JhcHBlcikge1xuXHRcdFx0YXJncy5wdXNoKGFyZy5pbnRlcm5hbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChhcmcpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGFyZ3M7XG59O1xuXG5jb25zdCByb3V0ZXJXcmFwcGVyS2V5cyA9IE9iamVjdFxuXHQua2V5cyhSb3V0ZXJXcmFwcGVyLnByb3RvdHlwZSlcblx0LmNvbmNhdCgnaW50ZXJuYWwnKTtcblxuLyoqXG4gKiBFdmVyeXRoaW5nIGVsc2UganVzdCBuZWVkcyB0byBiZSBwYXNzZWQgb3ZlciB0byB0aGUgZXhwcmVzcyBpbnN0YW5jZS5cbiAqL1xuY29uc3QgcHJveHlFeHByZXNzID0gKHdyYXBwZXIpID0+IHtcblx0T2JqZWN0XG5cdFx0LmtleXMod3JhcHBlci5pbnRlcm5hbClcblx0XHQuZmlsdGVyKChrKSA9PiByb3V0ZXJXcmFwcGVyS2V5cy5pbmRleE9mKGspID09PSAtMSlcblx0XHQuZm9yRWFjaCgoaykgPT4ge1xuXHRcdFx0Y29uc3Qgb3JpZyA9IHdyYXBwZXIuaW50ZXJuYWxba107XG5cblx0XHRcdGlmKHR5cGVvZiBvcmlnID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIGpzY3M6ZGlzYWJsZVxuXHRcdFx0XHR3cmFwcGVyW2tdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8ganNjczplbmFibGVcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbFtrXS5hcHBseSh0aGlzLmludGVybmFsLCB1bndyYXAoYXJndW1lbnRzKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwgaywge1xuXHRcdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHdyYXBwZXIuaW50ZXJuYWxba107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0cmV0dXJuIHdyYXBwZXI7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSAoKSA9PiB7XG5cdGNvbnN0IGFwcCA9IGV4cHJlc3MoKTtcblx0cmV0dXJuIHByb3h5RXhwcmVzcyhuZXcgUm91dGVyV3JhcHBlcihhcHApKTtcbn07XG5cbmV4cG9ydHMuUm91dGVyID0gKG9wdGlvbnMpID0+IHtcblx0Y29uc3Qgcm91dGVyID0gZXhwcmVzcy5Sb3V0ZXIob3B0aW9ucyk7XG5cdHJldHVybiBwcm94eUV4cHJlc3MobmV3IFJvdXRlcldyYXBwZXIocm91dGVyKSk7XG59O1xuXG5PYmplY3Rcblx0LmtleXMoZXhwcmVzcylcblx0LmZpbHRlcigoaykgPT4gayAhPT0gJ1JvdXRlcicpXG5cdC5mb3JFYWNoKChrKSA9PiB7XG5cdFx0ZXhwb3J0c1trXSA9IGV4cHJlc3Nba107XG5cdH0pO1xuXG5cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
