'use strict';

const express = require('express');
const methods = require('methods').concat('all');

const isNil = (val) => {
	return val === null || val === undefined;
};

const createHandleWrapper = (handler) => {
	// TODO: maybe handle express `use` method as well?
	return (req, res, next) => {
		// express already handles error throwing, so no need to wrap this in
		// another try/catch.
		const ret = handler(req, res, next);

		// In some cases, it makes sense to just call the send method manually,
		// for example to stream data.
		if(isNil(ret)) {
			return;
		}

		// We have a thenable.
		if(typeof ret.then === 'function') {
			ret
				.then((r) => {
					if(!isNil(r)) {
						res.status(200).send(r);
					}
				}, next);
			return;
		}

		res.status(200).send(ret);
	};

};
// jscs:disable
const RouterWrapper = function(internal) {
	this.internal = internal;
};
// jscs:enable

methods.forEach((method) => {
	// No choice for this one...
	// jscs:disable
	RouterWrapper.prototype[method] = function(...args) {
		// jscs:enable
		
		// Theres a couple of cases that this needs to handle. The first is the
		// basic syntax with the string at the begning. For some of the
		//var args = Array.prototype.slice.call(arguments);
		const isRg = typeof args[0] === 'string';
		const handlerList = isRg ? args.slice(1) : args;
		const head = isRg ? args[0] : null;
//		if(typeof args[0] === 'string') {
//			handlerList = args.slice(1);
//			head = args[0];
//		} else {
//			handlerList = args;
//		}

		// And then I need to process potential arrays...
		const handlers = handlerList.map((handler) => {
			if(Array.isArray(handler)) {
				return handler.map(createHandleWrapper);
			}
			return createHandleWrapper(handler);
		});
		const passArgs = head ? [head].concat(handlers) : handlers;
		this.internal[method].apply(this.internal, passArgs);
	};
});

// jscs:disable
RouterWrapper.prototype.route = function() {
	// jscs:enable
	const router = this.internal.route.apply(this.internal, arguments);
	return new RouterWrapper(router);
};

// Remove wrapper instances before passing the arguments to the express
// instance.
// Hmm should this be recursive?
const unwrap = (w) => {
	const args = [];
	Array.prototype.forEach.call(w, (arg) => {
		if(arg instanceof RouterWrapper) {
			args.push(arg.internal);
		} else {
			args.push(arg);
		}
	});

	return args;
};

const routerWrapperKeys = Object
	.keys(RouterWrapper.prototype)
	.concat('internal');

/**
 * Everything else just needs to be passed over to the express instance.
 */
const proxyExpress = (wrapper) => {
	Object
		.keys(wrapper.internal)
		.filter((k) => routerWrapperKeys.indexOf(k) === -1)
		.forEach((k) => {
			const orig = wrapper.internal[k];

			if(typeof orig === 'function') {
				// jscs:disable
				wrapper[k] = function() {
					// jscs:enable
					return this.internal[k].apply(this.internal, unwrap(arguments));
				};
			} else {
				Object.defineProperty(wrapper, k, {
					get: () => {
						return wrapper.internal[k];
					}
				});
			}
		});
	return wrapper;
};

exports = module.exports = () => {
	const app = express();
	return proxyExpress(new RouterWrapper(app));
};

exports.Router = (options) => {
	const router = express.Router(options);
	return proxyExpress(new RouterWrapper(router));
};

Object
	.keys(express)
	.filter((k) => k !== 'Router')
	.forEach((k) => {
		exports[k] = express[k];
	});


